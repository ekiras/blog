---
layout: post
exclude: true
title: 'Spring Security : Create a Custom Authentication Filter'
date: '2015-01-23T15:45:00.002+05:30'
author: Ekansh Rastogi
tags:
- Security
- Spring Security
- Grails
modified_time: '2015-01-23T15:49:13.729+05:30'
blogger_id: tag:blogger.com,1999:blog-5485242750509374114.post-1761001943415187287
blogger_orig_url: http://ekiras.blogspot.com/2015/01/spring-security-create-custom-authentication-filter-in-grails.html
redirect_from: "/2015/01/spring-security-create-custom-authentication-filter-in-grails.html"
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h2>Points To Remember</h2>You may need to create an
    AuthenticatioFilter when you want to create a custom logic for handling the authentication filter. You may also want
    to create your own Authentication Provider, Entry Point, Authentication Token etc to customize the authentication
    process to a new level.<br/>
    <h2>Step 1 : Create a Filter</h2>Let us first create a class named <b>MyAuthenticationFilter </b>and then register
    it as a bean in <b>resources.groovy</b>.&nbsp;After we have created the class and registered the it as a bean, we
    can use this class as a filter for our custom spring security authentication.<br/><br/><b>Class :
        MyAuthenticationFilter.groovy</b><br/>
    <pre class="brush:java">package com.ekiras<br/><br/>import org.springframework.context.ApplicationEventPublisher<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br/>import org.springframework.security.authentication.event.InteractiveAuthenticationSuccessEvent<br/>import org.springframework.security.core.Authentication<br/>import org.springframework.security.core.AuthenticationException<br/>import org.springframework.security.core.context.SecurityContextHolder<br/>import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter<br/>import org.springframework.security.web.authentication.AuthenticationFailureHandler<br/>import org.springframework.security.web.authentication.AuthenticationSuccessHandler<br/><br/>import javax.servlet.FilterChain<br/>import javax.servlet.ServletException<br/>import javax.servlet.ServletRequest<br/>import javax.servlet.ServletResponse<br/>import javax.servlet.http.HttpServletRequest<br/>import javax.servlet.http.HttpServletResponse<br/><br/>/**<br/> * Created by ekansh on 19/1/15.<br/> */<br/>class MyAuthenticationFilter extends AbstractAuthenticationProcessingFilter{<br/><br/>    public static final String USERNAME = 'j_username';<br/>    public static final String PASSWORD = 'j_password';<br/><br/><br/>    AuthenticationSuccessHandler authenticationSuccessHandler<br/>    AuthenticationFailureHandler authenticationFailureHandler<br/>    ApplicationEventPublisher applicationEventPublisher<br/><br/><br/><br/>    protected MyAuthenticationFilter() {<br/>        super('/mylogin') // Register the url that will be intercepted by this filter.<br/>    }<br/><br/>    @Override<br/>    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)  throws IOException, ServletException {<br/>        HttpServletRequest request = (HttpServletRequest) req<br/>        HttpServletResponse response = (HttpServletResponse) resp<br/>       &nbsp;    //Check if the url contains the filterProcessUrl and required authentication is false, if not then pass the request to the next filter. <br/>        if (!request.getRequestURI().contains(filterProcessesUrl) &amp;&amp; !requiresAuthentication(request, response)) {<br/>            chain.doFilter(request, response)<br/>            return<br/>        }<br/><br/>        // Create an authentication token that will be returned.<br/>        Authentication authentication;<br/>        try{ // If the credentials to not match then an AuthenticationException is thrown.<br/>            authentication = attemptAuthentication(request, response)<br/>            // If successfully authenticated then pass the request to the success handler<br/>            if(authentication.authenticated)<br/>                successfulAuthentication(request,response,authentication)<br/>        }<br/>        catch(AuthenticationException exception){<br/>            // Pass the request to authentication failure handler.<br/>            unsuccessfulAuthentication(request,response,exception)<br/>            return<br/>        }<br/>    }<br/><br/>    @Override<br/>    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {<br/>        return true;<br/>    }<br/><br/><br/>    @Override<br/>    Authentication attemptAuthentication(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws AuthenticationException, IOException, ServletException {<br/><br/>        String username = getUsername(httpServletRequest);<br/>        String password = getPassword(httpServletRequest);<br/><br/>        Authentication authentication = new UsernamePasswordAuthenticationToken(username, password);<br/><br/>        return this.authenticationManager.authenticate(authentication);<br/>    }<br/>    @Override<br/>    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException{<br/>        SecurityContextHolder.getContext().setAuthentication(authentication)<br/>        applicationEventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authentication, this.class))<br/>        authenticationSuccessHandler.onAuthenticationSuccess(request,response,authentication)<br/>    }<br/><br/>    @Override<br/>    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException{<br/>        authenticationFailureHandler.onAuthenticationFailure(request,response, exception)<br/>    }<br/><br/>    // Get the username from the request object<br/>    String getUsername(HttpServletRequest request){<br/>        return request.getParameter(USERNAME);<br/>    }<br/><br/>    // get the password from the request object<br/>    String getPassword(HttpServletRequest request){<br/>        return request.getParameter(PASSWORD);<br/>    }<br/>}<br/></pre>
    <div><br/></div>
    Now we register the class as a spring bean in resources.groovy like this. <br/>
    <pre class="brush:java">    myAuthenticationFilter(MyAuthenticationFilter){<br/>        authenticationManager = ref('authenticationManager')<br/>        sessionAuthenticationStrategy = ref('sessionAuthenticationStrategy')<br/>        authenticationSuccessHandler = ref('authenticationSuccessHandler')<br/>        authenticationFailureHandler = ref('authenticationFailureHandler')<br/>        rememberMeServices = ref('rememberMeServices')<br/>        authenticationDetailsSource = ref('authenticationDetailsSource')<br/>        filterProcessesUrl = '/mylogin'<br/>    }</pre>
    <br/>Now you need to register this filter in the deployment descriptor so that the these effects take place. There
    are two ways of doing this<br/><br/>
    <ol style="text-align: left;">
        <li>You can declare your filter using a filter chain in <b>Config.groovy</b>. See the documentation <a
                href="http://grails-plugins.github.io/grails-spring-security-core/guide/filters.html" target="_blank">how
            to do this.</a></li>
        <li>&nbsp;You can declare the filter in bootsrap as following<br/>
            <pre class="brush:java">SpringSecurityUtils.clientRegisterFilter('myAuthenticationFilter', SecurityFilterPosition.SECURITY_CONTEXT_FILTER.order + 10)</pre>
        </li>
    </ol>
    <b><br/></b></div>