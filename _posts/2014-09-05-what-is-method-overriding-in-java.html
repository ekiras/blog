---
layout: post
title: What is Method Overriding in Java ??
date: '2014-09-05T00:04:00.001+05:30'
author: Ekansh Rastogi
tags:
- Java
modified_time: '2014-10-10T19:06:54.713+05:30'
thumbnail: http://1.bp.blogspot.com/-0RibQb_l7Ms/VAiSuDw5VsI/AAAAAAAAAGc/DTH68iEy1Ag/s72-c/polymorphism.gif
blogger_id: tag:blogger.com,1999:blog-5485242750509374114.post-404802248392284990
blogger_orig_url: http://ekiras.blogspot.com/2014/09/what-is-method-overriding-in-java.html
redirect_from: "/2014/09/what-is-method-overriding-in-java.html"
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div class="hl-imp">When a base class extends a super class and both the base class and the super class have a method with same name, same types of parameters and same number of parameters, then the two methods are said to be overriden. </div><div class="hl-note"><b>Points To Remember</b></div><ul style="text-align: left;"><li>Overriding of methods is <b>always done in a base class</b> or in other words, we always override a parent class method.</li><li>The <b>access specifier</b> of the overriden method <b>can not be less than the parent class </b>method's access specifier e.g if a parent class method is marked as protected, you can override it with access specifiers protected and public only.</li><li>Overriden methods should have <b>same number of arguments and of same type</b>.</li><li>The <b>return type</b> of the overridden method <b>should be same </b>as the overriding method.</li><li>We <b>cannot override a static methods.</b></li><li>We <b>cannot override private methods</b> of parent class in a base class, it will give a compile time error if we try to do so.</li></ul><div class="hl-note"><b>Example Of Overriding</b></div>The following is a simple example of overriding.<br /><pre class="brush : java">class Base {<br />  public Base(){<br />     System.out.println("Base Constructor");     <br />  }<br />  public void show() {<br />     System.out.println("Base show");     <br />  }<br />}<br />   <br />class Derived extends Base {<br /><br />  public Derived(){<br />     System.out.println("Derived Constructor");     <br />  }<br />  public void show() {  // overrides the Base's show()<br />     System.out.println("Derived show");  <br />  }<br />  public static void main(String[] args) {<br />      Base obj = new Derived();<br />      obj.show();<br />  }  <br />}<br /></pre>The above example will give an output<br /><pre class="output"><br />Base Constructor<br />Derived Constructor<br />Derived show<br /></pre>This is because the super class is always referenced before a sub class is referenced. Thus the Base Constructor is referenced first and the show method of Base class is made available to the JVM. Now the JVM references the Derived class and again finds the show() method. Thus it will keep the show() method of the Dervired class and whenever the class to show() method is made, the JVM will class the show() method of the Derived class. <div class="hl-note"><b>Overriding Use Case</b></div><img align="right" border="0" src="http://1.bp.blogspot.com/-0RibQb_l7Ms/VAiSuDw5VsI/AAAAAAAAAGc/DTH68iEy1Ag/s1600/polymorphism.gif" height="313" width="320" />Suppose we want to make a function <b>speak()</b> that returns how a particular animal speaks e.g dog barks , ducks quack, cats meow.<br />We can do this in the following ways.<br /><ul style="text-align: left;"><li>We can have a speak() method inside each class Dog, Cat or Duck and we can access the speak() method by making object of that class. <b>This method is a bad practice and must be avoided.</b></li><li>We make a super class Animal and all other classes like Dog, Cat etc extend this class. Now we can give reference of the Animal class to all the objects of Dog, Cat , Duck etc.</li></ul><pre class="brush : java">class Animal {<br />  public void speak(){<br />     System.out.println("My language is not known"); <br />  }<br />}<br /><br />class Cat extends Animal {<br />  public void speak() {<br />     System.out.println("I am a cat and i do Meow Meow");     <br />  }<br />}<br /><br />class Dog extends Animal {<br />  public void speak() {<br />     System.out.println("I am a dog and i do Woof Woof");     <br />  }<br />}<br /><br />class Duck extends Animal {<br />  public void speak() {<br />     System.out.println("I am a duck and i do Quack Quack");     <br />  }<br />}<br /><br />class Alien extends Animal {<br />}<br /><br />class Test {<br /><br />  public static void main(String[] args) {<br /><br />     Animal dog = new Dog();<br />     Animal cat = new Cat();<br />     Animal duck = new Duck();<br />     Animal alien = new Alien();<br />     speak(dog);<br />     speak(cat);<br />     speak(duck); <br />     speak(alien);  <br />  }  <br /><br />  public static void speak(Animal animal){<br />   animal.speak();<br />  }<br /><br /><br />}<br /></pre><b>Output of the above example is as follows</b><pre class="output"><br />I am a dog and i do Woof Woof<br />I am a cat and i do Meow Meow<br />I am a duck and i do Quack Quack<br />My language is not known<br /></pre></div>In the above example the method speak() of class Test takes the parameter animal object and prints what does that animal speaks. This method does not know about what type of animal it is having. Its only gets to know at runtime.<br /><br /><b>This is how Polymorphism(Dynamic Binding) works and this example shows how you can achieve polymorphism with the help of Method Overriding.</b><br /><br /><br /></div>